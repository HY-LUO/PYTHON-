[TOC]

# Python基础补充

# 一.垃圾回收机制详解

## 1.概念引入

### 1.什么是垃圾回收机制

​	垃圾：当一个比变量引用计数为零时，称作垃圾（此时该变量用不到，因为我们定义变量的目的是拿来用的，当它为零时就用不到了

​	垃圾回收机制（简称GC）是Python解释器自带的一种机制，用于回收不可用的变量值所占用的内存空间，即：当变量值的引用计数为0的时候，该变量值会被Python自动回收它的内存占用

### 2.为什么要有垃圾回收机制

​	程序运行过程中会申请大量的内存空间，而对于一些无用的内存空间如果不及时清理的话会 导致内存使用殆尽(内存溢出)，导致程序崩溃，因此管理内存是- 件重要且繁杂的事情,而python解释 器自带的垃圾回收机制把程序员从繁杂的内存管理中解放出来。

### 3.垃圾回收机制的原理

​	Python的GC模块主要运用了“引用计数”(reference counting)来跟踪和回收垃圾。在引用计数的基础上,还可以通过“标记-清除”(mark and sweep)解决容器对象可能产生的循环引用的问题,并且通过“分代回收”(generation collection)以空间换取时间的方式来进一步提高垃圾回收的效率。



## 2.引用计数

 什么是引用计数：变量值被引用的次数

定义变量使拿来用的，引用的方式：直接引用,间接引用

```python
x=10                #直接引用
print(id(x))

l = ['a',x]         #间接引用
print(id(x))
# 265512256
# 265512256
```

- 引用计数增加

  ```python
  x = 10      #10的引用计数为1
  y = x       #10的引用计数为2
  z = x       #10的引用计数为3
  ```

- 引用计数减少

  ```Python
  del x       #解除变量名x与值10的绑定关系，此时引用计数为2
  del y       #解除变量名y与值10的绑定关系，此时引用计数为1
  			#注意：del是解除绑定
  ```



## 3.标记清除

​	容器对象(比如: list， set, dict, class， instance) 都可以包含对其他对象的引用，所以都可能产生循环引用。而“标记-清除计数就是为了解决循环引用的问题。



## 4.分代回收

* 概念：

  基于引用计数的回收机制，每次回收内存，都需要把所有对象的引用计数都遍历一遍，这是非常消耗时间的，于是引入了分代回收来提高回收效率，分代回收采用的是用“空间换时间”的策略。

  * 分代:

  分代回收的核心思想是:在历经多次扫描的情况下，都没有被回收的变量, gc机制就会认为，该变量是常用变量，gc对其扫描的频率会降低，具体实现原理如下:

  分代指的是根据存活时间来为变量划分不同等级（也就是不同的代）
  新定义的变量，放到新生代这个等级中，假设每隔1分钟扫描新生代一次，如果发现变量依然被引用，那么该对象的权重（权重本质就是个整数）加一，当变量的权重大于某个设定得值（假设为3），会将它移动到更高一级的青春代，青春代的gc扫描的频率低于新生代（扫描时间间隔更长），假设5分钟扫描青春代一次，这样每次gc需要扫描的变量的总个数就变少了，节省了扫描的总时间，接下来，青春代中的对象，也会以同样的方式被移动到老年代中。也就是等级（代）越高，被垃圾回收机制扫描的频率越低

  * 回收:

  回收依然是使用引用计数作为回收的依据

![](https://img2020.cnblogs.com/blog/1739645/202003/1739645-20200305111128826-439545327.png)

虽然分代回收可以起到提升效率的效果，但也存在一定的缺点:

例如一个变量刚刚从新生代移入青春代，该变量的绑定关系就解除了，该变量应该被回收，但青春代的扫描频率低于新生代，所以该变量的回收就会被延迟。